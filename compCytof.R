#' Compute spillover probability and correct for spillover
#'
#' @import magrittr
#' @import dplyr
#' @import CATALYST
#' @import flowCore
#' @import tidyr
#' @export
#'
#' @param sce \code{\link[SingleCellExperiment]{SingleCellExperiment}} for the 
#'   real cells
#' @param sce_bead \code{\link[SingleCellExperiment]{SingleCellExperiment}} for 
#'   the bead experiment
#' @param marker_to_barc Table that maps the marker to the barcode in the beads 
#'   experiment
#' @param runmed_k Integer width of median window for smoothing the ECDF
#'
#' @return A \code{\link[SingleCellExperiment]{SingleCellExperiment}} object
#'
#' @examples
#' sce <- prepData(mp_cells)    # real cells
#' sce_bead <- prepData(ss_exp) # beads
#' sce <- spillR::compCytof(sce, sce_bead, overwrite = FALSE)
compCytof <- function(sce, sce_bead, marker_to_barc, overwrite = FALSE, 
                      runmed_k = 11) {
  
  if(!("marker" %in% colnames(marker_to_barc)))
    stop("marker_to_barc needs to have column marker")
  if(!("barcode" %in% colnames(marker_to_barc)))
    stop("marker_to_barc needs to have column barcode")

  tfm <- function(x) asinh(x/5) # TODO: this should not be hardcoded
  
  # --------- experiment with beads ---------
  
  counts_bead <- t(assay(sce_bead, "counts"))
  counts_bead <- floor(counts_bead)
  counts_bead <- as_tibble(counts_bead)
  
  channel_names <- rowData(sce_bead)[,"channel_name"]
  names(counts_bead) <- channel_names
  counts_bead <- mutate(counts_bead, barcode = sce_bead$bc_id)
  
  # what markers spillover into target marker?
  sm <- metadata(sce_bead)$spillover_matrix
  
  # --------- experiment with real cells ---------
  
  channel_names <- rowData(sce)[, "channel_name"]
  counts_real <- t(assay(sce, "counts"))
  counts_real <- floor(counts_real)
  colnames(counts_real) <- channel_names
  counts_real <- as_tibble(counts_real)
  
  # --------- iterator over markers ---------
  
  fit_list <- lapply(rownames(sm), 
    function(target_marker) {
      
      spillover_markers <- names(which(sm[,target_marker] > 0))
      spillover_barcodes <- marker_to_barc %>% 
        dplyr::filter(marker %in% spillover_markers) %>%
        dplyr::select("barcode")%>%
        pull()
      
      tb_bead <- counts_bead %>% 
        dplyr::filter(barcode %in% spillover_barcodes) %>% 
        dplyr::select(all_of(c(target_marker, "barcode"))) %>% 
        mutate(type = "beads")
      
      tb_real <- counts_real %>% 
        dplyr::select(all_of(target_marker)) %>%
        mutate(barcode = "none") %>%
        mutate(type = "real cells")
      
      # rename barcodes to marker names
      for(i in seq(length(spillover_barcodes))) {
        ids <- tb_bead$barcode == spillover_barcodes[i]
        tb_bead[ids, "barcode"] <- spillover_markers[i]
      }
      
      spillover_markers <- setdiff(spillover_markers, target_marker)
      compensate(tb_real, tb_bead, target_marker, spillover_markers, runmed_k)
      
    }
  )
  names(fit_list) <- rownames(sm)
  
  # --------- save results in SingleCellExperiment class ---------
  
  # find inactive channels
  used_channel <- rowData(sce_bead)$is_bc
  channels_out <- channel_names[used_channel == FALSE]
  channels_null <- names(which(sapply(fit_list, is.null)))
  channels_out <- union(channels_out, channels_null)

  # prepare new assay matrices
  data <- matrix(NA, nrow = nrow(counts_real), ncol = length(channel_names))
  data <- data.frame(data)
  colnames(data) <- channel_names
  spillprob <- data
  
  rep(NA, ncol(data))
  
  for(i in 1:length(channel_names)){
    if(channel_names[i] %in% channels_out){
      
      # no correction
      data[,i] <- counts_real[,channel_names[i]]
      
    }
    else {
      
      # keep the corrected counts
      tb_compensate <- fit_list[[channel_names[i]]]$tb_compensate
      data[,i]      <- tb_compensate$corrected
      
      # keep the smoothed spillover probability for diagnostic plots
      spillprob[,i] <- tb_compensate$spill_prob
      
    }
  }
  
  # save compensated counts
  c <- ifelse(overwrite, "counts", "compcounts")
  assay(sce, c, FALSE) <- t(data)
  
  # save compensated transformed counts
  c <- ifelse(overwrite, "exprs", "compexprs")
  assay(sce, c, FALSE) <- t(tfm(data))
  
  # save spillover probabilities
  assay(sce, "spillprob", FALSE) <- t(spillprob)
  
  # add spillover meta data for diagnostic plots
  beads_distr <- lapply(fit_list, function(fit) fit$tb_bead)
  spillover_est <- lapply(fit_list, function(fit) fit$tb_spill_prob)
  metadata(sce)$beads_distr <- beads_distr
  metadata(sce)$spillover_est <- spillover_est

  return(sce)
  
}
